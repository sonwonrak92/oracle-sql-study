# **01 ) 인덱스**

> 대용량 테이블에서 필요한 데이터만 빠르고 효율적으로 액세스할 목적으로 사용하는 오브젝트.
>
> 가장 일반적으로 사용되는 인덱스 구조는 B tree.
>
> key, column 순으로 정렬되어 있다.

### (1)범위 스캔

- 인덱스의 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다.

- 수평적 탐색과도 같은 의미라고 볼 수 있다.

- 일반적인 힙 구조 테이블에서는 범위스캔이 **불가능**하다. 데이터가 올바른 정렬상태로 유지되도록 사용자가 주의를 하더라도 옵티마이저가 그것을 신뢰하지 않기에 range scan 같은 실행계획을 수립하지 않는다.

  

### (2)인덱스 기본 구조

- **Root Block, Branch Block** 에는 하위 노드 블록을 찾아가기 위한 *DBA(Data Block Address)* 정보를 갖고 있다.

- 또한, 각 브랜치 노드의 첫 번째 엔트리는 키 값이 없는 *특별한 엔트리인 lmc*가 존재한다.

  > LeftMost Child(lmc) : 명시적인 키 값을 가지고 있지 않고 ' 키 값을 가진 첫 번째 엔트리보다 작은 값'을 의미

  

- **Leaf Block** 에는 *인덱스 키 칼럼과 테이블 레코드의 주소정보(rowid)*를 가지고 있다. Leaf Block는 항상 키 컬럼 순으로 정렬되어있기에 '범위스캔'이 가능하다. 키 값이 같을 때는 rowid순으로 정렬된다.

- 오라클은 인덱스의 구성 칼럼이 모두 null인 레코드는 저장하지 않는다.

- **브랜치 노드의 특징**

  - 브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치
  - 브랜치 노드상의 키 값은 하위 노드의 값의 범위 (5000이면 5000~부터 라는 의미)
  - 인덱스 분할에 의해 새로운 블록이 추가되거나 삭제(다른 브렌치의 자식노드로 이동)될 때만 갱신된다.

- **리프 노드의 특징**

  - 테이블 레코드에서 값이 갱신되면 리프 노드 인덱스 키 값도 같이 갱신(delete & insert)된다. 
  - 리프 노드상의 엔트리 키 값이 갱신되더라도 브랜치 노드에는 영향을 주지 않는다.

  

### (3)인덱스 탐색

- 인덱스 탐색에는 '**수직적**', '**수평적**' 탐색이 존재한다.
- **수직적 탐색**은 루트에서 리프블록까지 탐색하는 방법이다.
- **수평적 탐색**은 리프블록에서 좌,우로 스캔하는 방법이다. 
- **브랜치 블록 스캔**
  - 브랜치 블록을 스캔할 때는 뒤에서부터 스캔하는 방식이 유리하지만, 오라클의 오피셜은 아니다. 책에서는 뒤에서부터 스캔한다는 가정으로 개념을 설명하고있다.
  - 또한, 찾고자하는 키 값이 작은 엔트리를 따라 내려간다. 만약 3을 찾는다면 2의 마지막 부분의 엔트리를 따라내려간다.
- **결합 인덱스 구조와 탐색** - 사진보며 설명
- **ROWID 포맷**
  - 데이터 오브젝트 번호(6자리)
  - 데이터파일 번호(3자리) - 로우가 속한 데이터파일 번호
  - 블록번호(6자리) - 해당 로우가 저장된 데이터 블록 번호
  - 로우번호(3자리)- 블록 내에서 각 로우에 붙여진 일련번호, 0부터시작

파티션이란?)

논리적테이블은 1개이며, 물리적으로 테이블을 분할하는 방법

```sql
CREATE TABLE PRD_DATE_TABLE (
    YYMM VARCHAR2(6) NOT NULL,
    YYMMDD VARCHAR2(8) NOT NULL
)
PARTITION BY RANGE(CLOSE_MONTH)
(
    PARTITION PRD_DATE_TABLE_2012 VALUES LESS THAN ('201301') TABLESPACE PRD_USER,
    PARTITION PRD_DATE_TABLE_2013 VALUES LESS THAN ('201401') TABLESPACE PRD_USER,
    PARTITION PRD_DATE_TABLE_2014 VALUES LESS THAN ('201501') TABLESPACE PRD_USER,   
    PARTITION PRD_DATE_TABLE_ELSE VALUES LESS THAN (MAXVALUE) TABLESPACE PRD_USER
);
```

# **02) 인덱스 기본원리**

> 인덱스 선두 컬럼이 조건절에 사용되지 않으면 범위 스캔을 하지 않아, 인덱스 풀 스캔 또는 테이블 풀 스캔방식을 선택한다. 또한 선두 컬럼을 사용하더라도 인덱스를 사용하지 못하는 경우도 있다.

### (1)인덱스 사용이 불가능하거나 범위 스캔이 불가능한 경우 

- 범위스캔 불가능한 예시
  - 인덱스 컬럼을 조건절에서 가공할 경우
  - 부정형을 이용한 비교
  - IS NOT NULL 조건의 사용

```sql
SELECT *
FROM A
WHERE SUBSTR(A.NAME,1,2) = '안녕'

WHERE A.NAME <> 'A' 

WHERE A.DEPT_NO IS NOT NULL
```

### (2)인덱스 컬럼 튜닝 예시

```SQL
SELECT *
FROM A 
WHERE SUBSTR(NAME,1,2) = '이름'  => NAME LIKE '이름%'

WHERE SAL*12 = 36000 => SAL = 36000/12

WHERE TO_CHAR(DATE,'YYYYMMDD') = '20190101' =>      DATE >= TO_DATE('20190101','YYYYMMDD')
											AND DATE < TO_DATE('20190101','YYYYMMDD')+1

```

### (3)묵시적 형변환

- 숫자형과 문자형이 비교될 때는 숫자형이 우선시되며, 문자형이 숫자형으로 형변환을 한다. 그러나 LIKE로 비교할 경우 숫자형이 문자형으로 변환된다.
- 드라이빙 테이블을 유의해서 인덱스컬럼의 가공을 피해야한다.
- **DECODE함수가 가진 규칙을 유의해야한다.** P35
- 문자형 숫자형 -> 숫자형, 문자형 날짜형 -> 날짜형

# 03)인덱스 스캔 방식

### (1)Index Range Scan

> 루트 블록에서 리프 블록까지 수직적으로 탐색한 다음 리프 블록을 필요한 범위안에서 스캔하는 방식.
>
> B-Tree 인덱스의 가장 일반적이고 정상적인 엑세스 방식.

- Index Range Scan이 가능하게 하려면 인덱스를 구성하는 선두컬럼이 조건절에 사용되어야 한다.이 과정을 거쳐 생성된 결과는 정렬된 상태가 되기 때문에 order by 연산을 생략할 수 있다. 물론 인덱스 칼럼순서대로 정렬을 할 경우만.

### (2)Index Full Scan

- 실제로는 수직적 탐색 후 수평적 탐색을 시도하지만, 수평적으로만 탐색한다고 생각하면 쉽다.
- 데이터의 분포도가 좋은 경우에는 table full scan이 더 유리할 수도 있다. 인덱스 스캔의 경우 데이터에 해당하는 만큼 테이블에 엑세스 해야되기 때문이다.

### (3)Index  Fast Full Scan (index_ffs)

- Index Full Scan의 병렬처리라고 보면된다. 하지만 다수의 블록을 가지고 작업을 하기때문에 인덱스에 의한 sort기능은 없다고 보면된다. 리프 블럭의 논리적인 순서대로 처리하는 것이 아닌 물리적인 순서대로 처리한다.

### (4)Index Unique Scan

- 수직적 탐색만으로 데이터를 찾는 스캔 방식으로 '=' 조건으로 작동한다. 유니크 인덱스라도 범위검색 조건의 경우 Index Range Scan으로 처리된다.

### (5)Index Skip Scan(index_ss) - p45 그림1-9로 설명

- 인덱스 선두 컬럼이 조건절에 빠졌어도 인덱스를 활용하는 새로운 스캔 방식이다. 9i 버전에서 등장했다.
- 선두 컬럼의 value 개수가 적고 후행 컬럼의 value 개수가 많을 때 유용하다.
- 첫 번째 리프블록을 항상 방문하고 마지막 리프 블록도 항상 방문한다.
- 성별,생년월일 같은 경우에 유용함. 성별은 남,여 두가지만 존재하며 생년월일의 경우 분포도가 다양하기 때문에.
- 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 "가능성이 있는" 리프 블록만 골라서 액세스하는 방식이다.

```sql
급여가 500 이하인 경우가 조건일 경우
선두컬럼인 성별에 따른 후행컬럼인 급여를 기준으로 리프 블록을 골라서 액세스한다.
```

