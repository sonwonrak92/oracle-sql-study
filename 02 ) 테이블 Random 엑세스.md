62~98

# **01 ) 테이블 Random 엑세스 부하**

> 쿼리에서 참조되는 컬럼이 인덱스에 모두 포함되는 경우가 아니라면 인덱스 스캔 이후 테이블 Random 엑세스 발생

- 메인 메모리 DB와의 비교
  - 잘 튜닝된 OLTP성 오라클 DB라면 버버 캐시 히트율(읽고자 하는 데이터 블록이 디스크가 아닌 버퍼 캐시에서 찾아지는 비율)이 99%이상이므로 대부분 디스크를 경유하지 않고 메모리사엥서 I/O를 수행한다. 하지만 인메모리DB만큼 빠르지는 않다.
  - 결국 인덱스를 경유해 테이블을 엑세스하는 비용이 있기 때문이다.
- ROWID는 우편주소에 해당하며, 인메모리DB는 전화번호라고 생각하면된다. 우편물을 전달하기위해 직접 주소를 통해 찾는 시간이 있지만 인메모리는 전화번호만으로 바로 해당 집으로 연결하기 때문이다.
- 디스크로부터 블록을 퍼올리고 올려진 블록에서 인덱스를 통한 접근을 한다. 따라서 매번 블록을 퍼올릴때 FREE버퍼를 할당 받는다. 

### 인덱스 클러스터링 팩터(Clustering Factor, 이하 FC)

- 데이터가 서로 모여있는 정도. 동일한 성격의 데이터 분포도

예시) 인덱스에서 데이터를 읽을 때 테이블 블록 9번까지 캐시에 올려놓았는데, CF가 나쁜 테이블이라서 11번 12번 테이블블록을 필요로 할 수가 있다. 이때 이미 올려둔 테이블 블록은 9번까지라서 11번과 12번 테이블 블록을 올리기위해 물리적인 디스크에 I/O를 하면서 횟수를 증가시킨다.

### 인덱스 손익분기점

- 데이터가 일정량을 넘는 순간 테이블 풀스캔이 인덱스레인지스캔보다 빠른 시점

# **02) 테이블 Random 엑세스 최소화 튜닝**

### 인덱스 컬럼 추가

```SQL
SELECT *
FROM EMP
WHERE DEPTNO = 30
AND SAL > = 2200
위의 쿼리를 실행시키면 DEPTNO = 30인 것 중 SAL이 2200 이상인 인덱스레인지스캔을 탄다.
따라서 SAL칼럼을 인덱스에 추가시키는 것이 좋지만 새로운 인덱스를 생성하는 것이 아닌 IDX01에 칼럼만 추가하는 것으로도 큰 효과를 본다.
```

### 인덱스만  읽고 처리

### 차세대 시스템 구축 시 주의 사항

- 데이터 이관하는 과정에서 CF가 나빠지면서 느려지는 경우가 존재한다. 